# Forecast support, experimental coding
# probably all this will be rewritten, put in a different directory, etc.

import numpy
import cdtime
import cdms2
import copy
from cdms2 import CDMSError

def two_times_from_one( t ):
    """Input is a time representation, either as the long int used in the cdscan
    script, or as a cdtime comptime (component time) object.  Output is the same
    time, using _both_ types."""
    if isinstance(t,long):
        tl = t
        year = tl / 1000000000L
        rem = tl % 1000000000L
        month = rem / 10000000L
        rem =   rem % 10000000L
        day =     rem / 100000
        allsecs = rem % 100000
        sec =     allsecs%60
        allmins = allsecs/60
        min =  allmins%60
        hour = allmins/60
        tc = cdtime.comptime(year,month,day,hour,min,sec)
    else:
        # I'd like to check that t is type comptime, but although Python
        # prints the type as <type 'comptime'> it won't recognize as a type
        # comptime or anything similar.  Note that cdtime.comptime is a C
        # function available from Python.
        tc = t
        tl = tc.year * 1000000000L
        tl += tc.month * 10000000L
        tl += tc.day   * 100000
        tl += tc.hour * 3600
        tl += tc.minute *60
        tl += tc.second.__int__()
    return tl,tc

class forecast():
    """represents a forecast starting at a single time"""

    def __init__( self, tau0time, dataset_list, path="" ):
        """tau0time is the first time of the forecast, i.e. the time at which tau=0.
        dataset_list is used to get the forecast file from the forecast time.
        Each list item should look like this example:
        [None, None, None, None, 2006022200000L, 'file2006-02-22-00000.nc']
        Typically dataset_list = fm[i][1] where fm is the output of
        cdms2.dataset.parseFileMap and fm[i][0] matches the variables of interest.

        N.B.  This is like a CdmsFile.  Creating a forecast means opening a file,
        so you should call forecast.close() to close it.
        """
        self.fctl,self.fct = two_times_from_one( tau0time )
        print self.fctl, self.fct

        filenames = [l[5] for l in dataset_list if l[4]==self.fctl]
        if len(filenames)>0:
            filename = filenames[0]
        else:
            raise CDMSError, "Cannot find filename for forecast %d"%self.fctl
        self.filename = path + '/' + filename
        self.file = cdms2.open( self.filename )

    def close( self ):
        self.file.close()

    def __call__( self, varname ):
        """Reads the specified variable from this forecast's file."""
        return self.file(varname)

    def __getitem__( self, varname ):
        """Reads variable attributes from this forecast's file."""
        return self.file.__getitem__(varname)


class forecasts():
    """represents a set of forecasts"""

    def __init__( self, tau0times, dataset_file, path="" ):
        """tau0times is a list of times, each representing a forecast.  Each list
        item is the first time of the forecast, i.e. the time at which tau=0.
        dataset_file is the name of a dataset xml file generated by
        "cdscan --forecast ..."
        As for the forecast class this opens files, so you should call
        forecasts.close() to close them.
        """
        # >>>> TO DO >>>> initialize by a slice, e.g. time1:time2 <<<<
        # >>>> (as well as a list [time1,time2,...])
        # Note that even if the forecasts are set up with a list of forecast
        # times you can later refer to those times with a slice (range), it being
        # understood that the range is selecting a subset of the list.

        # dataset_list is used to get a forecast file from a forecast time.
        # Each list item should look like this example:
        # [None, None, None, None, 2006022200000L, 'file2006-02-22-00000.nc']
        # Typically dataset_list = fm[i][1] where fm is the output of
        # cdms2.dataset.parseFileMap and fm[i][0] matches the variables of interest.
        self.dataset=cdms2.openDataset( dataset_file )
        fm=cdms2.dataset.parseFileMap(self.dataset.cdms_filemap)
        dataset_list = fm[0][1]
        for f in fm[1:]:
            dataset_list.extend(f[1])

        self.fcs = [ forecast( t, dataset_list, path ) for t in tau0times ]

    def close( self ):
        self.dataset.close()
        for fc in self.fcs:
            fc.close()

    def __call__( self, varname ):
        """Reads the specified variable for all the forecasts.
        Creates and returns a new variable which is dimensioned by forecast
        as well as the original variable's dimensions."""
        # >>>> TO DO: copy the masks <<<<
        # >>>> TO DO: set more attributes, maybe by copying them all <<<<
        # Note: unlike in __getitem__, there's too much data to start with something
        # like self.dataset(varname), which would have made things easier...
        vars = [ fc(varname) for fc in self.fcs ]
        v0 = vars[0]
        a = numpy.asarray([ v.data for v in vars ])
        v = cdms2.tvariable.TransientVariable(a)
        ltvd = len(v0._TransientVariable__domain)
        v._TransientVariable__domain[1:ltvd+1] = v0._TransientVariable__domain[0:ltvd]
        # v._TransientVariable__domain[0]=( cdms2.axis.TransientVirtualAxis('ifc',len(self.fcs)),)
        v._TransientVariable__domain[0] = self.forecast_axis( varname )
        if hasattr( v0, 'coordinates' ):
            v.coordinates = 'iforecast ' + v0.coordinates
        if hasattr( v0, 'id' ):
            v.id = v0.id
        return v

    def forecast_axis( self, varname ):
        """returns a tuple (axis,start,length,true_length) where axis is in the
        forecast direction"""
        # TO DO: see whether I can get an axis without starting with a variable name.
        # Most variables will have a suitable domain.

        var = self.dataset[varname]
        # ... var is a DatasetVariable, used here just for its domain
        dom = copy.deepcopy(getattr(var,'domain',[]))
        # ...this 'domain' attribute has an element with an axis, etc.
        # representing all forecasts; so we want to cut it down to match
        # those forecasts in self.fcs.
        for i in range(len(dom)):
            # The domain will have several directions, e.g. forecast, level, latitude.
            # There should be only one forecast case, named fctau0.
            # domdir is a tuple (axis,start,length,true_length) where
            # axis is a axis.Axis and the rest of the tuple is int's.
            # I don't know what true_length is, but it doesn't seem to get used
            # anywhere, and is normally the same as length.
            domdir = dom[i]
            if getattr(domdir[0],'id',None)=='fctau0':
                # Force the axis to match self.fcs :
                # More precisely the long int times self.fcs[i].fctl should match
                # the axis data. The axis partition and .length need changing too.
                # I don't know what to do with axis._node_ <<<<
                domdir1 = 0
                domdir2 = len(self.fcs)
                domdir3 = len(self.fcs)
                axis = copy.copy(domdir[0])
                axis._data_ = [ f.fctl for f in self.fcs ]
                axis.length = len(axis._data_)
                axis.partition = axis.partition[0:axis.length]
        return ( axis, domdir1, domdir2, domdir3 )


    def __getitem__( self, varname ):
        """returns whatever the forecast set has that matches the given
        attribute, typically a DatasetVariable.
        """
        var = self.dataset[varname]
        # var is a DatasetVariable and consists of lots of attributes.

        # The attribute which needs to be changed is 'domain' - it will normally
        # have an element with an axis, etc. representing all forecasts; so we
        # want to cut it down to match those forecasts in self.fcs.
        dom = copy.deepcopy(getattr(var,'domain',[]))
        for i in range(len(dom)):
            if getattr(domdir[0],'id',None)=='fctau0':
                dom[i] = self.forecast_axis(varname)
        setattr(var,'domain',dom)
                
        return var
    
